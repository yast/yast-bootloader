/**
 * File:
 *      include/bootloader/generic/boot_loader_location_widget.ycp
 *
 * Module:
 *      Bootloader installation and configuration
 *
 * Summary:
 *      Widgets for configuring the boot loader location
 *
 * Authors:
 *      Joachim Plack <jplack@suse.de>
 *
 * $Id$
 *
 */


{
textdomain "bootloader";

import "BootCommon";

include "bootloader/generic/widget_funcs.ycp";


// boot loader location widget

/**
 * option cache and reader function
 */
map<string,any> _bll_options = nil;

/**
 * return map of boot loader options from global_options, cache them if
 * necessary
 */
map<string,any> BLL_options () {
    if ( _bll_options == nil)
    {
	_bll_options = filter( string key, any value, BootCommon::global_options, {
	    return substring(key,0,5) == "boot_";
	});

	y2milestone("_bll_options initialized");
    }
    return _bll_options;
}


/**
 * Init function of a widget
 * @param widget string widget key
 */
void BLL_Init (string widget) {
    generic_Init(widget, BLL_options(), BootCommon::globals);
}


/**
 * Store function of a widget
 * @param widget string widget key
 * @param event map event that caused the operation
 */
void BLL_Store (string widget, map event) {
    generic_Store(widget, event, BLL_options(), _globals_store_data);
}


/**
 * Handle function of a widget
 * @param key any widget key
 * @param event map event description of event that occured
 * @return symbol always nil
 */
symbol BLL_Handle (string key, map event) {
    if (event["EventReason"]:"" == "ValueChanged") {
        BootCommon::location_changed = true;
    }
    return generic_Handle (key, event);
}

/**
 * Validate function of a widget
 * @param widget string widget key
 * @param event map event that caused validation
 * @return boolean true if validation succeeded
 */
boolean BLL_Validate (string widget, map event)
{
    y2milestone("Called from widget %1 through event %2", widget, event);
    // FIXME: call perl-Bootloader
    return true;
}


map<string,any> genericBootLoaderLocationWidget () {
    map<string,any> options = BLL_options();

    list<string> val = splitstring((string)BootCommon::global_options["boot"]:"", ":");
    string boottype = val[0]:"select";

    map<string, any> gt_map = $[];
    term targetlist = nil;

    if (boottype == "multi") {
	gt_map = generic_Term(options, "check");
	targetlist = (term) gt_map["term"]:nil;
    }
    else if (boottype == "select") {
	gt_map = generic_Term(options, "radio");
	targetlist = `RadioButtonGroup (`id (`location), (term) gt_map["term"]:nil);
    }
    else {
	y2error("Unknown option type %1 for boot loader location dialog. Ignored\n", boottype);
	return nil;
    }

    return $[
        "widget" : `custom,
        "custom_widget" : `Frame (_("Boot Loader Location"), targetlist),
	"init" : BLL_Init,
	"store" : BLL_Store,
        "help" : generic_Help("boot-loader-location") + (string) gt_map["help"]:"",
	"handle" : BLL_Handle,
	"validate_type" : `function,
	"validate_function" : BLL_Validate,
    ];
}

} // include end

/*
 * Local variables:
 *     mode: ycp
 *     mode: font-lock
 *     mode: auto-fill
 *     indent-level: 4
 *     fill-column: 78
 * End:
 */
