/**
 * File:
 *      include/bootloader/routines/widgets.ycp
 *
 * Module:
 *      Bootloader installation and configuration
 *
 * Summary:
 *      Common widgets for being used by several bootloaders
 *
 * Authors:
 *      Jiri Srain <jsrain@suse.cz>
 *      Olaf Dabrunz <od@suse.de>
 *
 * $Id$
 *
 */


{

textdomain "bootloader";

import "CWM";
import "Initrd";
import "Label";
import "Mode";
import "Storage";
import "StorageDevices";
import "TablePopup";
import "Popup";

include "bootloader/routines/helps.ycp";

/**
 * Init function for widget value
 * @param widget any id of the widget
 */
void SectionOptionInit (string widget) {
    UI::ChangeWidget (`id (widget), `Value,
	BootCommon::current_section[widget]:"");
}

/**
 * Store function of a widget
 * @param widget any widget key
 * @param event map event description of event that occured
 */
void SectionOptionStore (string widget, map event) {
    BootCommon::current_section[widget]
	= UI::QueryWidget (`id (widget), `Value);
}

/**
 * Map of fallback handlers for events on sections
 */
map<string,any> section_handlers = $[
    "init" : SectionOptionInit,
    "store" : SectionOptionStore,
];


/**
 * Validate function of the name widget
 * @param widget any widget key
 * @param event map event description of event that occured
 * @return boolean true if widget settings ok
 */
boolean SectionNameValidate (string widget, map event) {
    list<string> existing = [];
    foreach (map<string,any> s, BootCommon::sections, {
	existing = add (existing, s["name"]:"");
    });
    existing = (list<string>)filter (string l, existing, {
	return l != BootCommon::current_section_name;
    });
    existing = (list<string>)add (existing, "");
    string new = (string)UI::QueryWidget (`id (widget), `Value);

    if (contains (existing, new))
    {
	usedNameErrorPopup ();
	return false;
    }
    return true;
}

/**
 * Store function of the name widget
 * @param widget any widget key
 * @param event map event description of event that occured
 */
void SectionNameStore (string widget, map event) {
    string value = (string)UI::QueryWidget (`id (widget), `Value);
    if (Bootloader::getLoaderType () != "grub")
    {
	value = BootCommon::replaceAll (value, " ", "_");
	if (size (value) > 15)
	    value = substring (value, 0, 15);
    }
    BootCommon::current_section[widget] = value;
}

/**
 * Init function of widget
 * @param widget any id of the widget
 */
void KernelImageInit (string widget) {
    list<string> available = (list<string>)SCR::Read (.target.dir, "/boot");
    available = filter (string f, available, {
	return substring (f, 0, 13) == "/boot/vmlinuz";
    });
    if (size (available) == 0)
	available = ["/boot/vmlinuz"];
    UI::ChangeWidget (`id (widget), `Items, available);
    SectionOptionInit (widget);
}

/**
 * Handle function of a widget
 * @param widget any widget key
 * @param event map event description of event that occured
 * @return symbol to return to wizard sequencer, or nil
 */
symbol KernelImageHandle (string widget, map event) {
    string current = (string)UI::QueryWidget (`id (widget), `Value);
    // file open popup caption
    current = UI::AskForExistingFile (current, "*", _("Kernel Image"));
    if (current != nil)
	UI::ChangeWidget (`id (widget), `Value, current);
    return nil;
}

/**
 * Init function of widget
 * @param widget any id of the widget
 */
void InitrdInit (string widget) {
    list<string> available = (list<string>)SCR::Read (.target.dir, "/boot");
    available = filter (string f, available, {
	return substring (f, 0, 12) == "/boot/initrd";
    });
    if (size (available) == 0)
	available = ["/boot/initrd"];
    UI::ChangeWidget (`id (widget), `Items, available);
    SectionOptionInit (widget);
}

/**
 * Handle function of the initrd widget
 * @param widget any widget key
 * @param event map event description of event that occured
 * @return symbol to return to wizard sequencer, or nil
 */
symbol InitrdHandle (string widget, map event) {
    string current = (string)UI::QueryWidget (`id (widget), `Value);
    // file open popup caption
    current = UI::AskForExistingFile (current, "*", _("Initial RAM Disk"));
    if (current != nil)
	UI::ChangeWidget (`id (widget), `Value, current);
    return nil;
}


/**
 * Init function of the root device widget
 * @param widget any id of the widget
 */
void RootDeviceInit (string widget) {
    y2milestone ("RootDeviceInit: %1", widget);
    list<string> available = BootCommon::getPartitionList (`root);
    // if we mount any of these devices by id, label etc., we add a hint to
    // that effect to the item
    y2milestone ("RootDeviceInit: getHintedPartitionList for %1", available);
    available = BootCommon::getHintedPartitionList (available);
    UI::ChangeWidget (`id (widget), `Items, available);
    UI::ChangeWidget (`id (widget), `Value,
	(BootCommon::getHintedPartitionList ([BootCommon::current_section[widget]:""]))[0]:"");
}

/**
 * Store function of the root device widget
 * @param widget any widget key
 * @param event map event description of event that occured
 */
void RootDeviceStore (string widget, map event) {
    BootCommon::current_section[widget]
	= (splitstring( (string)UI::QueryWidget (`id (widget), `Value), " "))[0]:"";
}

/**
 * Handle function of the root device widget
 * @param widget any widget key
 * @param event map event description of event that occured
 * @return symbol to return to wizard sequencer, or nil
 */
symbol RootDeviceHandle (string widget, map event) {
    if (event["EventReason"]:nil != "ValueChanged")
	return nil;
    // append hint string when user changed root device
    string current
	= (splitstring( (string)UI::QueryWidget (`id (widget), `Value), " "))[0]:"";
    // check against the list of existing partitions
    list<string> available = BootCommon::getPartitionList (`root);
    if (contains(available, current))
	UI::ChangeWidget (`id (widget), `Value,
	    (BootCommon::getHintedPartitionList ([current]))[0]:"");
    return nil;
}

/**
 * Init function of widget
 * @param widget any id of the widget
 */
void VgaModeInit (string widget) {
    list<map> vga_modes = Initrd::VgaModes ();
    list items = maplist (map m, vga_modes, {
	return `item (`id (sformat ("%1", m["mode"]:0)),
	    // combo box item
	    // %1 is X resolution (width) in pixels
	    // %2 is Y serolution (height) in pixels
	    // %3 is color depth (usually one of 8, 16, 24, 32)
	    // %4 is the VGA mode ID (hexadecimal number)
	    sformat (_("%1x%2, %3 bits (mode %4)"),
		m["width"]:0, m["height"]:0, m["color"]:0, m["mode"]:0));
    });
    // item of a combo box
    items = prepend (items, `item (`id ("normal"), _("Text Mode")));
    UI::ChangeWidget (`id (widget), `Items, items);
    SectionOptionInit (widget);
}

/**
 * Init function of widget
 * @param widget any id of the widget
 */
void ChainloaderInit (string widget) {
    list<string> available = BootCommon::getPartitionList (`boot_other);
    UI::ChangeWidget (`id (widget), `Items, available);
    SectionOptionInit (widget);
}

/**
 * Handle function of the chainloader widget
 * @param widget any widget key
 * @param event map event description of event that occured
 * @return symbol to return to wizard sequencer, or nil
 */
symbol ChainloaderHandle (string widget, map event) {
    string current = (string)UI::QueryWidget (`id (widget), `Value);
    // file open popup caption
    current = UI::AskForExistingFile (current, "*", _("Device to Boot"));
    if (current != nil)
	UI::ChangeWidget (`id (widget), `Value, current);
    return nil;
}

/**
 * Widget for selecting section type
 * @return term widget
 */
term SectionTypesWidget () {
    integer count = 0;
    term contents = `VBox ();
    if (BootCommon::current_section_name != "")
    {
	contents = add (contents, `Left (`RadioButton (`id ("clone"),
	    // radio button
	    _("Clone Selected Section"), true)));
	count = count + 1;
    }
    list<string> section_types = ["image", "xen", "chainloader"];
    map<string,string> section_types_descr = $[
	// radio button
	"image" : _("Kernel (Linux)"),
	// radio button
	"xen" : _("Kernel via XEN"),
	// radio button (don't translate 'chainloader')
	"chainloader" : _("Other System (Chainloader)"),
    ];
    foreach (string t, section_types, {
	if (count > 0)
	    contents = add (contents, `VSpacing (0.4));
	count = count + 1;
	contents = add (contents, `Left (`RadioButton (`id (t),
	    section_types_descr[t]:t, count == 1)));
    });
    // frame
    contents = `Frame (_("Section Type"), `VBox (
	`VSpacing (1),
	`HBox (
	    `HSpacing (2),
	    `RadioButtonGroup (`id (`sect_type), contents),
	    `HSpacing (2)
	),
	`VSpacing (1)
    ));
    return contents;
}

/**
 * Handle function of a widget
 * @param widget string widget key
 * @param event map event description of event that occured
 * @return symbol to return to wizard sequencer, or nil
 */
symbol SectionTypeHandle (string widget, map event) {
    if (event["ID"]:nil != `next)
	return nil;
    string selected = (string)
	UI::QueryWidget (`id (`sect_type), `CurrentButton);
    if (selected != "clone")
    {
	BootCommon::current_section = $[
	    "type" : selected,
	];
    }
    else
    {
	BootCommon::current_section["name"] = "";
	// FIXME: the problem with missing YaST commnet in menu.lst
	// it seems be correct if original_name stay same...
	// BootCommon::current_section["original_name"] = "";
	BootCommon::current_section["__auto"] = false;
	// fix for problem with cloning section
	if (haskey(BootCommon::current_section,"lines_cache_id"))
		BootCommon::current_section = remove(BootCommon::current_section, "lines_cache_id");
    }
    y2milestone ("Added section template: %1", BootCommon::current_section);
    return nil;
}



/**
 * Cache for CommonSectionWidgets
 */
map<string,map<string,any> > _common_section_widgets = nil;

/**
 * Get common widgets for loader sections
 * @return a map describing common loader section related widgets
 */
map<string,map<string,any> > CommonSectionWidgets () {
    if (_common_section_widgets == nil)
    {
	  _common_section_widgets = $[
	    "name" : $[
		// text entry
		"label" : _("Section &Name"),
		"widget" : `textentry,
		"validate_type" : `function,
		"validate_function" : SectionNameValidate,
		"store" : SectionNameStore,
		"help" : SectionNameHelp (),
	    ],
	    "kernel" : $[
		"widget" : `custom,
		"custom_widget" : Stage::initial ()
		    ? `TextEntry (`id ("kernel"), `opt (`hstretch),
			// text entry
			_("&Kernel"))
		    : `HBox (
			`ComboBox (`id ("kernel"), `opt (`editable, `hstretch),
			    // combo box
			    _("&Kernel"),
			    []),
			`VBox (
			    `Label (""),
			    `PushButton (`id (`kernel_browse),
				Label::BrowseButton ())
			)
		    ),
		"init" : KernelImageInit,
		"help" : KernelHelp (),
		"handle" : KernelImageHandle,
		"handle_events" : [ `kernel_browse ],
	    ],
	    "initrd" : $[
		"widget" : `custom,
		"custom_widget" : Stage::initial ()
		    ? `TextEntry (`id ("initrd"), `opt (`hstretch),
			// text entry
			_("&Initial RAM Disk"))
		    : `HBox (
			`ComboBox (`id ("initrd"), `opt (`editable, `hstretch),
			    // combo box
			    _("&Initial RAM Disk"),
			    []),
			`VBox (
			    `Label (""),
			    `PushButton (`id (`initrd_browse),
				Label::BrowseButton ())
			)
		    ),
		"init" : InitrdInit,
		"handle" : InitrdHandle,
		"handle_events" : [ `initrd_browse ],
		"help" : InitrdHelp (),
	    ],
	    "root" : $[
		"widget" : `combobox,
		// combo box
		"label" : _("Root &Device"),
		"opt" : [ `editable, `hstretch, `notify ],
		"init" : RootDeviceInit,
		"handle" : RootDeviceHandle,
		"store" : RootDeviceStore,
		"help" : RootDeviceHelp (),
	    ],
	    "vga" : $[
		"widget" : `combobox,
		// combo box
		"label" : _("&VGA Mode"),
		"opt" : [ `editable, `hstretch ],
		"init" : VgaModeInit,
		"help" : VgaModeHelp (),
	    ],
	    "append" : $[
		// text entry
		"label" : _("Other Kernel &Parameters"),
		"widget" : `textentry,
		"help" : AppendHelp (),
	    ],
	    "chainloader" : $[
		"widget" : `custom,
		"custom_widget" : `HBox (
			`ComboBox (`id ("chainloader"),
			    `opt (`editable, `hstretch),
			    // combo box
			    _("&Device"),
			    []),
			Stage::initial ()
			    ? `VBox ()
			    : `VBox (
				`Label (""),
				`PushButton (`id (`chainloader_browse),
				    Label::BrowseButton ())
			    )
		    ),
		"init" : ChainloaderInit,
		"handle" : ChainloaderHandle,
		"handle_events" : [ `chainloader_browse ],
		"help" : ChainloaderHelp (),
	    ],
	    "section_type" : $[
		"widget" : `func,
		"widget_func" : SectionTypesWidget,
		"handle" : SectionTypeHandle,
		"help" : SectionTypeHelp (),
	    ],
	];
    }
    return _common_section_widgets;
}

} // include end
