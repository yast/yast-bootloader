
/**
 * File:
 *      modules/BootELILO.ycp
 *
 * Module:
 *      Bootloader installation and configuration
 *
 * Summary:
 *      Module containing specific functions for ELILO configuration
 *      and installation
 *
 * Authors:
 *      Joachim Plack <jplack@suse.de>
 *      Jiri Srain <jsrain@suse.cz>
 *      Andreas Schwab <schwab@suse.de>
 *
 * $Id$
 *
 */

{

// FIXME paths will be probably changed because of bugzilla 21644

module "BootELILO";

textdomain "bootloader";

import "BootArch";
import "BootCommon";
import "Installation";
import "Kernel";
import "Mode";
import "Report";
import "Stage";
import "Storage";

include "bootloader/elilo/helps.ycp";
include "bootloader/routines/popups.ycp";
include "bootloader/generic/dialogs.ycp";


// private variables

/**
  * Name of EFI entry when read settings
  */
global string old_efi_entry = nil;

/**
  * Should be original EFI entry removed?
  */
global boolean remove_old_efi = true;

/**
  * elilo.conf path
  */
global string elilo_conf_filename = "/boot/efi/SuSE/elilo.conf";

/**
  * True if EFI entry should be recreated
  */
global boolean create_efi_entry = true;

/**
  * True if the EFI layout was changed
  */
global boolean efi_layout_changed = false;

/**
 * The name of the entry in the EFI menu
 */
global string efi_entry_name = "";

string efi_vendor = "SuSE";

// misc. functions

/**
  * Return mountpoint of partition holding EFI data
  * @return mountpoint if partition holding EFI data
  */
global define string getEfiMountPoint () {
    string mountpoint = "/";
    // FIXME: UGLY HACK because of testsuites
    map mountpoints = $[];
    if (Mode::test ())
        mountpoints = $["/" : ["/dev/hda2"], "/boot" : ["/dev/hda1"]];
    else
        mountpoints = Storage::GetMountPoints();
    if (haskey (mountpoints, "/boot/efi"))
    {
        mountpoint = "/boot/efi";
    }
    else if (haskey (mountpoints, "/boot"))
    {
        mountpoint = "/boot";
    }
    y2milestone ("Mountpoint of EFI: %1", mountpoint);
    return mountpoint;
}


/**
  * Get directory containing elilo.conf relative to EFI partition's root
  * @return directory containing elilo.conf relative to EFI root
  */
global define string getEliloConfSubdir () {
    return sformat ("/efi/%1", efi_vendor);
}


/**
  * Get path of elilo.conf relative to EFI partition's root
  * @return string path of elilo.conf relative to EFI partition's root
  */
global define string getEliloConfSubpath () {
    return sformat ("%1/elilo.conf", getEliloConfSubdir ());
}


/**
  * Return path to elilo.conf file
  * @return string path to elilo.conf
  */
global define string getEliloConfFilename () {
    // FIXME config file name location should be read from Library
    //  and it should not be needed here!!!
    string ret = sformat ("%1/efi/%2/elilo.conf", getEfiMountPoint (),
        efi_vendor);
    y2milestone ("elilo.conf sould be located at %1", ret);
    return ret;
}

// wrapper function to adjust to new grub name sceme
map<string,any> CreateLinuxSection (string title) {
    map<string,any> section =
      BootCommon::CreateLinuxSection (title);

    // replace "kernel" by "image"
    if (haskey(section, "kernel")) {
      section["image"] = section["kernel"]:"";
      section = remove(section, "kernel");
    }
 
    return section;
}



/**
 * Propose sections to bootloader menu
 * modifies internal sreuctures
 */
global void CreateSections () {
    map<string,any> linux = CreateLinuxSection ("linux");
    map<string,any> failsafe = CreateLinuxSection ("failsafe");

    // append for default section is in global
    // FIXME do it later
    //    if (haskey (linux, "append"))
    //  	linux = remove (linux, "append");

    BootCommon::sections = [ linux, failsafe ];
}


/**
 * Propose global options of bootloader
 * modifies internal structures
 */
global void CreateGlobals () {
    BootCommon::globals = $[
    // FIXME do it later
    //	"append" : BootArch::DefaultKernelParams (""),
	"default" : BootCommon::translateSectionTitle ("linux"),
	"timeout" : "8",
	"prompt" : "1",
    ];
    // FIXME TODO in the library
    /*	BootCommon::globals = [
	    $[ "key" : "prompt", "value" : true ],
	    $[ "key" : "read-only", "value" : true ],
	    $[ "key" : "relocatable", "value" : true ],
	];*/
}


// general functions


/**
  * Export bootloader settings to a map
  * @return bootloader settings
  */
global define map Export () {
    map ret = BootCommon::Export ();
    ret["old_efi_entry"] = old_efi_entry;
    ret["remove_old_efi"] = remove_old_efi;
    ret["elilo_conf_filename"] = elilo_conf_filename;
    ret["create_efi_entry"] = create_efi_entry;
    return ret;
}


/**
  * Import settings from a map
  * @param settings map of bootloader settings
  */
global define boolean Import (map<string, any> settings) {
    BootCommon::Import (settings);
    old_efi_entry = (string) (settings["old_efi_entry"]:nil);
    remove_old_efi = settings["remove_old_efi"]:true;
    elilo_conf_filename = getEliloConfFilename ();
    create_efi_entry
        = settings["create_efi_entry"]:(settings["location"]:"" != "");
    return true;
}


/**
  * Read settings from disk
  * @return boolean true on success
  */
global define boolean Read (boolean reread) {
	import "Product";
	boolean efi_entry_found = false;
	elilo_conf_filename = getEliloConfFilename ();
	// copy old elilo.conf from /boot/<something> to /etc in case of upgrade
	// (if /etc/elilo.conf doesn't exist)
	if (SCR::Read (.target.size, "/etc/elilo.conf") <= 0
	    && SCR::Read (.target.size, elilo_conf_filename) > 0)
	{
	    SCR::Execute (.target.bash, sformat (
		"/bin/cp %1 /etc/elilo.conf", elilo_conf_filename));
	}
	SCR::Execute (.target.bash, "/bin/touch /etc/elilo.conf");
	BootCommon::DetectDisks ();
	boolean ret = BootCommon::Read (reread);
	efi_entry_name
	    = (string)SCR::Read (.sysconfig.bootloader.LOADER_LOCATION);
	y2milestone ("EFI entry: %1", efi_entry_name);
	// check for meaningless EFI entry name in sysconfig
	if ("mbr" == efi_entry_name || "" == efi_entry_name
	    || nil == efi_entry_name)
	{
	    string efi_path = BootCommon::replaceAll (
		getEliloConfSubpath (), "/", "\\");
	    // Read Firmware setting from NVRam
	    map efi_status = (map)SCR::Execute (.target.bash_output, sformat (
		"/usr/sbin/efibootmgr |grep \"%1\"", efi_path));
	    if (efi_status["exit"]:0 != 0)
	    {
		efi_entry_name = Product::name;
	    }
	    else
	    {
		string output = efi_status["stdout"]:"";
		list lines = splitstring (output, "\n");
		output = lines[0]:"";
		if (regexpmatch (output, "Boot.*\* (.*)  HD"))
		{
		    efi_entry_name
			= regexpsub (output, "Boot.*\* (.*)  HD", "\\1");
		    efi_entry_found = true;
		}
		else
		{
		    efi_entry_name = Product::name;
		}
	    }
	}
	else
	{
	    efi_entry_found = 0 == SCR::Execute (.target.bash, sformat (
            "/usr/sbin/efibootmgr |grep \"%1\"", efi_entry_name));
	}
	create_efi_entry = false;
	old_efi_entry = efi_entry_found ? efi_entry_name : (string)nil;
	return ret;
}


/**
  * Reset bootloader settings
  */
global define void Reset (boolean init) {
    if (Mode::autoinst ())
        return;
    remove_old_efi = true;
    create_efi_entry = true;
    BootCommon::Reset(init);
}


/**
  * Propose bootloader settings
  */
global define void Propose () {
    import "Product";
    if (! BootCommon::was_proposed)
    {
        create_efi_entry = true;
        efi_entry_name = Product::name;
    }
    if (! Stage::initial ())
        create_efi_entry = true;
    if (Mode::update ())
        create_efi_entry = false;
    elilo_conf_filename = getEliloConfFilename ();
    BootCommon::DetectDisks ();
    BootCommon::del_parts = BootCommon::getPartitionList (`deleted);

    if (BootCommon::sections == nil || size (BootCommon::sections) == 0)
    {
        CreateSections ();
        BootCommon::kernelCmdLine = Kernel::GetCmdLine ();
    }
    else
    {
        if (Mode::autoinst ())
        {
    	y2debug ("Nothing to do for propose in AI mode");
        }
        else
    	BootCommon::FixSections (BootELILO::CreateSections);
    }
    if (BootCommon::globals == nil || size (BootCommon::globals) == 0)
    {
        CreateGlobals ();
    }

    if (efi_entry_name == "" || efi_entry_name == nil)
    {
        efi_entry_name = Product::name;
    }
    y2milestone ("EFI entry name: %1", efi_entry_name);
    y2milestone ("Proposed sections: %1", BootCommon::sections);
    y2milestone ("Proposed globals: %1", BootCommon::globals);
}


/**
 * Save all bootloader configuration files
 * @return boolean true if success
 */
global boolean Save (boolean clean, boolean init, boolean flush) {
    BootCommon::globals["efi_entry_name"] = efi_entry_name;
    // FIXME modify EFI? Entries to remove...
    boolean ret = BootCommon::Save (clean, init, flush);
    importMetaData();
    return ret;
}


/**
  * Display bootloader summary
  * @return a list of summary lines
  */
global define list<string> Summary () {
    // summary text, %1 is bootloader name (eg. LILO)
    list<string> result = [ sformat (_("Boot loader type: %1"),
        BootCommon::getLoaderName (BootCommon::getLoaderType (false), `summary)) ];
    if ( efi_entry_name == "" || efi_entry_name == nil || !create_efi_entry )
    {
        result =
    	    // summary text
    	    add (result, _("Do Not Create EFI Boot Manager Entry"));
    }
    else
    {
        result = add (result, sformat (
    	// summary text, %1 is label of the entry of EFI boot manager
    	_("Create EFI Boot Manager Entry %1"),
        efi_entry_name));
    }
    list<string> sects = [];
    foreach (map<string,any> s, BootCommon::sections, {
        string title = s["name"]:"";
            // section name "suffix" for default section
        string def = title == BootCommon::globals["default"]:"" ?
	      _(" (default)") :
	      "";
        sects = add (sects, sformat ("%1%2", title, def));
    });
    // summary text. %1 is list of bootloader sections
    result = add (result, sformat (_("Sections: %1"),
        mergestring (sects, ", ")));
    return result;
}


/**
 * Update read settings to new version of configuration files
 */
global define void Update () {
    /*
     * Update global options of bootloader
     * modifies internal sreuctures
     */
    BootCommon::globals["timeout"] = "8";
    BootCommon::globals["append"] = BootArch::DefaultKernelParams ("");

    BootCommon::UpdateSections (true, CreateLinuxSection);
    // FIXME EFI entry name
}


/**
  * Install the bootloader, display a popup with log if something
  *  goes wrong
  * @param command string command to install the bootloader
  * @param logfile string filename of file used to write bootloader log
  * @return boolean true on success
  */
// FIXME get rid of this function
define boolean installBootLoader (string command, string logfile) {
    y2milestone ("Running command %1", command);
    map exit = (map)SCR::Execute (.target.bash_output, command);
    boolean ret = 0 == exit["exit"]:1;
    if (! ret)
    {
        y2milestone ("Exit code of %1: %2", command, exit["exit"]:-1);
        string log = (string)SCR::Read (.target.string, logfile);
        log = log + exit["stdout"]:"" + exit["stderr"]:"";
        if (exit["exit"]:1 == 139)
        {
            // means: process received signal SIGSEGV
            // please, use some usual translation
            // proofreaders: don't change this text
            log = log + _("Segmentation fault");
        }

        errorWithLogPopup (sformat (
            // error popup - label, %1 is bootloader name
            _("Error Occurred while Installing %1"),
            BootCommon::getLoaderName (BootCommon::getLoaderType (false), `summary)), log);
    }
    return ret;
}


/**
  * Write bootloader settings to disk
  * @return boolean true on success
  */
global define boolean Write () {
    //	SCR::Execute (.target.bash, "/sbin/elilo");
    boolean ret = BootCommon::UpdateBootloader ();
  
    if (BootCommon::location_changed || create_efi_entry)
    {
        // FIXME shuold be handled completly through the library
        // remove existing end old menu entry
        list<string> efi_entries_to_remove = toset ([
	    efi_entry_name,
	    remove_old_efi ? old_efi_entry : ""
        ]);
        efi_entries_to_remove = filter (
	    string e,
	    efi_entries_to_remove,
	    ``(	e != nil && e != "")
	);

        foreach (string efi_label, efi_entries_to_remove, {
	    // delete bootentry for efi_label if available
	    string command = sformat(
		"BOOTENTRY=\"" +
		"`/usr/sbin/efibootmgr|sed -n 's/Boot\([0-9]*\)\* %1$/\1/p' `\";" +
		"if [ \"$BOOTENTRY\" ]; then " + 
		    "/usr/sbin/efibootmgr --delete-bootnum --bootnum $BOOTENTRY -q;" + 
		"fi",
		efi_label
	    );
	    y2milestone ("Running command %1", command);
	    ret = 0 == SCR::Execute (.target.bash, command);
	});

	map mp = Storage::GetMountPoints();
	string boot_dev = mp[getEfiMountPoint (), 0]:"/boot/efi";
	map splited = Storage::GetDiskPartition (boot_dev);
	any boot_part = splited["nr"]:0;
	any boot_disk = splited["disk"]:"";
	y2milestone ("Disk: %1, Part: %2", boot_disk, boot_part);

	if (efi_entry_name != "" && efi_entry_name != nil)
	{
	    string bl_logfile = "/var/log/YaST2/y2log_bootloader";
	    string bl_command = sformat (
		"/usr/sbin/efibootmgr -v --create --label \"%1\" " +
		"--disk %2 --part %3 " +
		"--loader '\\efi\\SuSE\\elilo.efi' --write-signature >> %4 2>&1",
		efi_entry_name, boot_disk, boot_part, bl_logfile);
	    ret = ret && installBootLoader (bl_command, bl_logfile);
	}
    }
    return ret;
}


global symbol WizardSequenzer() {
    y2milestone("Call generic WizardSequenzer");
    return `generic_new;
}


global map<string,symbol()> Dialogs () {
    return $[
	"loader"	: genericBootLoaderOptionsDialog,
    ];
}


/**
  * Return map of provided functions
  * @return a map of functions (eg. $["write"::Write])
  */
global map<string, any> GetFunctions () {
    return $[
        "export"	   : Export,
        "import"	   : Import,
        "read"		   : Read,
	"reset"		   : Reset,
        "propose"	   : Propose,
        "save"		   : Save,
        "summary"	   : Summary,
        "update"	   : Update,
        "write"		   : Write,
        "widgets"	   : genericWidgets,
        "wizard_sequencer" : WizardSequenzer,
        "dialogs"	   : Dialogs,
        "section_types"	   : section_types,
    ];
}


/**
 * Initializer of ELILO bootloader
 */
global void Initializer () {
    y2milestone ("Called ELILO initializer");
    BootCommon::current_bootloader_attribs = $[
        "propose" : true,
        "read" : true,
        "scratch" : true,
        "restore_mbr" : true,
        "bootloader_on_disk" : true,
    ];

    BootCommon::help_messages = (map<string,string>)
      union(BootCommon::help_messages,
    	mapmap(string key, string val, elilo_help_messages,
    	    { return $[ "elilo_" + key : val ]; }
    	       )
    	);
    y2debug("Initialized help_messages to %1", BootCommon::help_messages);
    BootCommon::descriptions = (map<string,string>)
      union(BootCommon::descriptions,
    	mapmap(string key, string val, elilo_descriptions,
    	    { return $[ "elilo_" + key : val ]; }
    	       )
    	);
    y2debug("Initialized help_messages to %1", BootCommon::help_messages);

    BootCommon::InitializeLibrary (false, "elilo");
    importMetaData();
}

/**
 * Constructor
 */
global define void BootELILO () {
    BootCommon::bootloader_attribs["elilo"] = $[
	"required_packages" : ["elilo"],
	"loader_name" : "ELILO",
	"initializer" : BootELILO::Initializer,
    ];
}
 
} // EOF

/*
 * Local variables:
 *     mode: ycp
 *     mode: font-lock
 *     mode: auto-fill
 *     indent-level: 4
 *     fill-column: 78
 * End:
 */
